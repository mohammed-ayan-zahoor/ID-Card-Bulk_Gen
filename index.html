<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered ID Card Generator (Double-Sided)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .step-card {
            transition: all 0.3s ease;
        }
        .canvas-wrapper {
            border: 4px solid transparent;
            transition: border-color 0.3s ease;
        }
        .canvas-wrapper.active {
            border-color: #ec4899;
        }
        .placeholder {
            position: absolute;
            border: 2px dashed #3b82f6;
            cursor: move;
            user-select: none;
            background-color: rgba(59, 130, 246, 0.2);
            padding: 4px;
            box-sizing: border-box;
        }
        .placeholder.text-placeholder {
            color: #1e40af;
            font-weight: 500;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
        }
        .placeholder.photo-placeholder {
            border-style: solid;
            border-color: #16a34a;
            background-color: rgba(22, 163, 74, 0.2);
            color: #14532d;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .placeholder.qr-placeholder {
            border-style: solid;
            border-color: #9333ea;
            background-color: rgba(147, 51, 234, 0.2);
            color: #581c87;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .qr-placeholder-preview {
            font-weight: 500;
            text-align: center;
            font-size: 12px;
            padding: 4px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="%239333ea" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="3"></rect><rect x="14" y="7" width="3" height="3"></rect><rect x="7" y="14" width="3" height="3"></rect><rect x="14" y="14" width="3" height="3"></rect></svg>');
            background-repeat: no-repeat;
            background-position: center 2px;
            background-size: 24px 24px;
            padding-top: 28px;
        }

        .placeholder.active {
            border-style: solid;
            border-color: #db2777;
            background-color: rgba(219, 39, 119, 0.2);
            z-index: 10;
        }
        .placeholder.active .resize-handle {
            display: block;
        }
        .delete-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
            line-height: 1;
            z-index: 20;
        }
        .placeholder:hover .delete-btn {
            opacity: 1;
        }
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            background: #db2777;
            border: 2px solid white;
            cursor: se-resize;
            display: none;
            z-index: 15;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            max-width: 500px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">AI-Powered ID Card Generator</h1>
            <p class="text-base md:text-lg text-gray-600 mt-2">Design both sides of your card, upload data, and generate print-ready sheets.</p>
        </header>
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Controls Column -->
            <div class="lg:col-span-1 space-y-6">
                <!-- Step 1: Card Design -->
                <div id="step1" class="bg-white p-6 rounded-xl shadow-md step-card">
                    <div class="flex items-center mb-4"><span class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-lg mr-4">1</span><h2 class="text-xl sm:text-2xl font-semibold">Card Setup</h2></div>
                    <p class="text-gray-600 mb-4">Choose an orientation. Default designs are provided, which you can replace.</p>
                                        
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Orientation</label>
                        <div class="flex justify-around bg-gray-100 rounded-lg p-1">
                            <button id="orientation-horizontal-btn" class="w-full px-3 py-2 rounded-md bg-blue-500 text-white">Horizontal</button>
                            <button id="orientation-vertical-btn" class="w-full px-3 py-2 rounded-md">Vertical</button>
                        </div>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Front Design</label>
                            <input type="file" id="bg-image-front-input" accept="image/jpeg, image/png" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Back Design</label>
                            <input type="file" id="bg-image-back-input" accept="image/jpeg, image/png" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                        </div>
                    </div>
                </div>
                <!-- Step 2: Upload Data -->
                <div id="step2" class="bg-white p-6 rounded-xl shadow-md step-card">
                    <div class="flex items-center mb-4"><span class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-lg mr-4">2</span><h2 class="text-xl sm:text-2xl font-semibold">Upload Data</h2></div>
                    <p class="text-gray-600 mb-4">Upload your Excel (.xlsx) or CSV file.</p>
                    <input type="file" id="data-file-input" accept=".xlsx, .csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                </div>
                                
                <!-- Step 3: AI/Manual Design -->
                <div id="step3" class="bg-white p-6 rounded-xl shadow-md step-card">
                    <div class="flex items-center mb-4"><span class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-lg mr-4">3</span><h2 class="text-xl sm:text-2xl font-semibold">Design Card</h2></div>
                    <p class="text-gray-600 mb-4">Click on a canvas (Front/Back) to edit it. Use AI or add fields manually.</p>
                    <div id="ai-controls" class="space-y-3 opacity-50">
                        <button id="ai-layout-btn" class="w-full bg-teal-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-600 transition-colors flex items-center justify-center" disabled>✨ Suggest Layout</button>
                        <button id="ai-title-btn" class="w-full bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 transition-colors flex items-center justify-center" disabled>✨ Generate Title</button>
                        <button id="add-all-headers-btn" class="w-full bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors flex items-center justify-center" disabled>Add All Data Fields</button>
                    </div>
                     <hr class="my-4">
                    <div id="add-placeholder-controls" class="space-y-4">
                        <div>
                            <label for="field-name-input" class="block text-sm font-medium text-gray-700 mb-1">Field Name:</label>
                            <input type="text" id="field-name-input" placeholder="e.g., FullName, Address" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <button id="add-text-btn" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Add Text Field</button>
                        <button id="add-photo-btn" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors">Add Photo Field</button>
                        
                        <!-- QR Code Field Selection -->
                        <div id="qr-field-container" class="border border-purple-300 rounded-md p-3 bg-purple-50 opacity-70">
                            <label for="qr-field-select" class="block text-sm font-medium text-purple-700 mb-1">QR Code Field:</label>
                            <select id="qr-field-select" class="w-full p-2 border border-purple-300 rounded-md shadow-sm focus:ring-purple-500 focus:border-purple-500 mb-2" disabled>
                                <option value="">Upload data to see fields</option>
                                <!-- Options will be populated when data is loaded -->
                            </select>
                            <button id="add-qr-btn" class="w-full bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 transition-colors">Add QR Code</button>
                        </div>
                    </div>
                </div>
                <!-- Edit Panel -->
                <div id="edit-panel" class="bg-white p-6 rounded-xl shadow-md step-card hidden">
                    <h2 class="text-xl sm:text-2xl font-semibold mb-4">Edit Selected Field</h2>
                    <div id="edit-controls" class="space-y-4"></div>
                </div>
                <!-- Layout Management -->
                <div id="layout-management" class="bg-white p-6 rounded-xl shadow-md step-card">
                    <div class="flex items-center mb-4">
                        <span class="bg-green-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-lg mr-4">S</span>
                        <h2 class="text-xl sm:text-2xl font-semibold">Layout Management</h2>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label for="layout-name" class="block text-sm font-medium text-gray-700 mb-1">Layout Name:</label>
                            <input type="text" id="layout-name" placeholder="e.g., Science Class, Math Class" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 mb-2">
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="save-layout-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-colors">Save Layout</button>
                            <button id="load-layout-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Load Layout</button>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="export-layouts-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">Export Layouts</button>
                            <button id="import-layouts-btn" class="bg-amber-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-700 transition-colors">Import Layouts</button>
                        </div>
                        <div>
                            <label for="layout-select" class="block text-sm font-medium text-gray-700 mb-1">Saved Layouts:</label>
                            <div class="flex gap-2">
                                <select id="layout-select" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                    <option value="">Select a saved layout...</option>
                                </select>
                                <button id="delete-layout-btn" class="bg-red-500 text-white px-3 py-2 rounded-md hover:bg-red-600">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Step 4: Generate -->
                <div id="step4" class="bg-white p-6 rounded-xl shadow-md step-card">
                    <div class="flex items-center mb-4"><span class="bg-purple-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-lg mr-4">4</span><h2 class="text-xl sm:text-2xl font-semibold">Generate Cards</h2></div>
                    <div class="space-y-4">
                        <button id="preview-btn" class="w-full bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors" disabled>Preview First Card</button>
                        <button id="generate-pdf-btn" class="w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700 transition-colors text-lg" disabled>Export to A4 PDF</button>
                        <button id="generate-zip-btn" class="w-full bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 transition-colors" disabled>Generate & Download ZIP</button>
                    </div>
                </div>
            </div>
            <!-- Canvas Column -->
            <div class="lg:col-span-2 space-y-8">
                <div id="front-canvas-wrapper" class="canvas-wrapper bg-white p-4 rounded-xl shadow-lg relative max-w-full mx-auto active">
                    <h3 class="text-center font-bold text-lg sm:text-xl mb-2">FRONT</h3>
                    <canvas id="front-canvas" class="w-full h-full rounded-md bg-gray-200"></canvas>
                    <div id="front-placeholder-wrapper" class="absolute top-0 left-0 w-full h-full"></div>
                </div>
                <div id="back-canvas-wrapper" class="canvas-wrapper bg-white p-4 rounded-xl shadow-lg relative max-w-full mx-auto">
                    <h3 class="text-center font-bold text-lg sm:text-xl mb-2">BACK</h3>
                    <canvas id="back-canvas" class="w-full h-full rounded-md bg-gray-200"></canvas>
                    <div id="back-placeholder-wrapper" class="absolute top-0 left-0 w-full h-full"></div>
                </div>
            </div>
        </div>
                
        <!-- Modals -->
        <div id="loading-modal" class="modal-overlay hidden"><div class="modal-content flex flex-col items-center"><div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24 mb-4"></div><p id="loading-text" class="text-lg font-semibold text-gray-700">Thinking...</p><style>.loader { border-top-color: #4f46e5; animation: spinner 1.5s linear infinite; } @keyframes spinner { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }</style></div></div>
        <div id="error-modal" class="modal-overlay hidden"><div class="modal-content"><h3 class="text-2xl font-bold text-red-600 mb-4">Error</h3><p id="error-text" class="text-gray-700"></p><button onclick="document.getElementById('error-modal').classList.add('hidden')" class="mt-6 bg-red-500 text-white font-bold py-2 px-6 rounded-lg">Close</button></div></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const bgImageFrontInput = document.getElementById('bg-image-front-input');
            const bgImageBackInput = document.getElementById('bg-image-back-input');
            const dataFileInput = document.getElementById('data-file-input');
            const fieldNameInput = document.getElementById('field-name-input');
            const addTextBtn = document.getElementById('add-text-btn');
            const addPhotoBtn = document.getElementById('add-photo-btn');
            const addQrBtn = document.getElementById('add-qr-btn');
            const previewBtn = document.getElementById('preview-btn');
            const generateZipBtn = document.getElementById('generate-zip-btn');
            const generatePdfBtn = document.getElementById('generate-pdf-btn');
            // Layout management elements
            const layoutNameInput = document.getElementById('layout-name');
            const saveLayoutBtn = document.getElementById('save-layout-btn');
            const loadLayoutBtn = document.getElementById('load-layout-btn');
            const deleteLayoutBtn = document.getElementById('delete-layout-btn');
            const layoutSelect = document.getElementById('layout-select');
            const exportLayoutsBtn = document.getElementById('export-layouts-btn');
            const importLayoutsBtn = document.getElementById('import-layouts-btn');
            const frontCanvas = document.getElementById('front-canvas');
            const backCanvas = document.getElementById('back-canvas');
            const frontCtx = frontCanvas.getContext('2d');
            const backCtx = backCanvas.getContext('2d');
            const frontCanvasWrapper = document.getElementById('front-canvas-wrapper');
            const backCanvasWrapper = document.getElementById('back-canvas-wrapper');
            const frontPlaceholderWrapper = document.getElementById('front-placeholder-wrapper');
            const backPlaceholderWrapper = document.getElementById('back-placeholder-wrapper');
            const editPanel = document.getElementById('edit-panel');
            const editControls = document.getElementById('edit-controls');
            const aiControls = document.getElementById('ai-controls');
            const aiLayoutBtn = document.getElementById('ai-layout-btn');
            const aiTitleBtn = document.getElementById('ai-title-btn');
            const addAllHeadersBtn = document.getElementById('add-all-headers-btn');
            const loadingModal = document.getElementById('loading-modal');
            const loadingText = document.getElementById('loading-text');
            const errorModal = document.getElementById('error-modal');
            const errorText = document.getElementById('error-text');
            const orientationHorizontalBtn = document.getElementById('orientation-horizontal-btn');
            const orientationVerticalBtn = document.getElementById('orientation-vertical-btn');
            const qrFieldSelect = document.getElementById('qr-field-select');
            
            // --- State ---
            let bgImages = { front: new Image(), back: new Image() };
            let data = [];
            let headers = [];
            let placeholders = { front: [], back: [] };
            let activeSide = 'front';
            let activePlaceholderId = null;
            let dragOffsetX, dragOffsetY;
            let isResizing = false;
            let orientation = 'horizontal';
            // --- Constants ---
            const HORIZONTAL_WIDTH = 856;
            const HORIZONTAL_HEIGHT = 540;
            const defaultBgDataUrl = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODU2IiBoZWlnaHQ9IjU0MCIgdmlld0JveD0iMCAwIDg1NiA1NDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkMSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6I0YzRjRGNjtzdG9wLW9wYWNpdHk6MSIgLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNUU3RUI7c3RvcC1vcGFjaXR5OjEiIC8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3Qgd2lkdGg9Ijg1NiIgaGVpZ2h0PSI1NDAiIGZpbGw9InVybCgjZ3JhZDEpIi8+PHBhdGggZD0iTTAgMCBIODU2IFYxMTAgQyA1MDAgMTUwLCAzNTYgNTAsIDAgOTAgWiIgZmlsbD0iIzI1NjNFQiIvPjxwYXRoIGQ9Ik04NTYgNTQwIEgwIFY0MzAgQyAzMDAgNDAwLCA1NTYgNTAwLCA4NTYgNDUwIFoiIGZpbGw9IiMzQjgyRjYiIGZpbGwtb3BhY2l0eT0iMC42Ii8+PC9zdmc+";
            const defaultBackBgDataUrl = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODU2IiBoZWlnaHQ9IjU0MCIgdmlld0JveD0iMCAwIDg1NiA1NDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkMiIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6I0YzRjRGNjtzdG9wLW9wYWNpdHk6MSIgLz48c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNUU3RUI7c3RvcC1vcGFjaXR5OjEiIC8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3Qgd2lkdGg9Ijg1NiIgaGVpZ2h0PSI1NDAiIGZpbGw9InVybCgjZ3JhZDIpIi8+PC9zdmc+";
            // --- Canvas Drawing ---
            const drawCardOnContext = async (targetCtx, side, width, height, rowData) => {
                targetCtx.clearRect(0, 0, width, height);
                const bg = bgImages[side];
                if (bg && bg.complete) {
                    targetCtx.drawImage(bg, 0, 0, width, height);
                }
                                
                if (!rowData) return;
                for (const p of placeholders[side]) {
                    const isStaticTitle = p.key === 'title' && p.staticText;
                    const value = isStaticTitle ? p.staticText : String(rowData[p.key] || '');
                    if (!value) continue;
                    const x = p.x * width;
                    const y = p.y * height;
                    
                    if (p.type === 'qr') {
                        const pWidth = p.width * width;
                        const pHeight = p.height * height;
                        try {
                            console.log(`Rendering QR code for value: ${value}`);
                            
                            // Create a QR code using QRCode.js
                            // Force a large enough size to be visible, minimum 150px
                            const qrSize = Math.max(Math.min(pWidth, pHeight), 150);
                            
                            // Create a hidden container for QR code generation
                            const qrContainer = document.createElement('div');
                            qrContainer.id = 'qr-container-temp';
                            qrContainer.style.position = 'absolute';
                            qrContainer.style.top = '-9999px';  // Hide it off-screen
                            qrContainer.style.left = '-9999px'; // Hide it off-screen
                            qrContainer.style.width = qrSize + 'px';
                            qrContainer.style.height = qrSize + 'px';
                            qrContainer.style.backgroundColor = '#ffffff';
                            qrContainer.style.padding = '0'; // Remove padding
                            qrContainer.style.boxSizing = 'border-box';
                            document.body.appendChild(qrContainer);
                            
                            // Create QR code instance with enhanced settings for visibility
                            new QRCode(qrContainer, {
                                text: value,
                                width: qrSize,
                                height: qrSize,
                                colorDark: '#000000', // Force black for best contrast
                                colorLight: '#ffffff', // White background
                                correctLevel: QRCode.CorrectLevel.L, // Lower error correction for cleaner codes
                                margin: 4 // Add margin to improve scannability
                            });
                            
                            // Add a label to the QR container to confirm what's being generated
                            const qrLabel = document.createElement('div');
                            qrLabel.textContent = `QR Code: ${value}`;
                            qrLabel.style.textAlign = 'center';
                            qrLabel.style.marginTop = '5px';
                            qrContainer.appendChild(qrLabel);
                            
                            // Get the QR code image from the container
                            const qrImage = qrContainer.querySelector('img');
                            if (qrImage) {
                                // Make sure to wait for the image to be fully loaded before drawing
                                await new Promise((resolve, reject) => {
                                    if (qrImage.complete) {
                                        resolve();
                                    } else {
                                        qrImage.onload = resolve;
                                        qrImage.onerror = reject;
                                        // Set a timeout just in case
                                        setTimeout(resolve, 500);
                                    }
                                });
                                
                                // Force the position to be in the upper right corner of the card
                                // Instead of using the placeholder position, we'll place it directly
                                // Use absolute positioning for more consistent results
                                const qrX = width * 0.65; // Right side of card - 65% from left edge
                                const qrY = height * 0.15; // Top part of card - 15% from top
                                const qrWidth = width * 0.25; // 25% of card width
                                const qrHeight = height * 0.25; // 25% of card height
                                
                                // Center the QR code within its area
                                const offsetX = (qrWidth - qrSize) / 2;
                                const offsetY = (qrHeight - qrSize) / 2;
                                
                                console.log(`Drawing QR at fixed position: x=${qrX}, y=${qrY}, width=${qrWidth}, height=${qrHeight}`);
                                
                                // Make it very visible with white background
                                targetCtx.fillStyle = '#ffffff';
                                targetCtx.fillRect(qrX, qrY, qrWidth, qrHeight);
                                
                                // Add a visible border around the QR area
                                targetCtx.strokeStyle = '#000000';
                                targetCtx.lineWidth = 2;
                                targetCtx.strokeRect(qrX, qrY, qrWidth, qrHeight);
                                
                                // Draw the QR code centered in the area
                                targetCtx.drawImage(qrImage, qrX + offsetX, qrY + offsetY, qrSize, qrSize);
                                
                                // Add a label at the bottom of the QR placeholder
                                targetCtx.fillStyle = '#000000';
                                targetCtx.font = 'bold 14px Inter';
                                targetCtx.textAlign = 'center';
                                targetCtx.textBaseline = 'top';
                                
                                // Position text at bottom of QR area
                                const textY = qrY + qrHeight - 20;
                                const textX = qrX + qrWidth / 2;
                                
                                // Draw QR label text
                                targetCtx.fillText(`${p.key}`, textX, textY);
                            }
                            
                            // Add debugging info
                            console.log(`QR Code rendered successfully for field: ${p.key}, value: ${value}`);
                            console.log(`QR Code position: x=${qrX}, y=${qrY}, width=${qrWidth}, height=${qrHeight}, qrSize=${qrSize}`);
                            
                            // Take a snapshot of the generated QR code for debugging
                            const qrDataUrl = qrImage.src;
                            console.log("QR code image data:", qrDataUrl.substring(0, 100) + "...");
                            
                            // Remove the QR container immediately after drawing to avoid interference
                            const container = document.getElementById('qr-container-temp');
                            if (container) document.body.removeChild(container);
                            
                        } catch (error) {
                            console.error(`Could not generate QR code for: ${value}`, error);
                            targetCtx.fillStyle = '#fee2e2'; 
                            targetCtx.fillRect(x, y, pWidth, pHeight);
                            targetCtx.fillStyle = '#ef4444'; 
                            targetCtx.textAlign = 'center'; 
                            targetCtx.fillText('QR Error', x + pWidth / 2, y + pHeight / 2);
                        }
                    } else if (p.type === 'photo') {
                        const pWidth = p.width * width;
                        const pHeight = p.height * height;
                        try {
                            const img = await loadImage(value);
                            
                            // Add rounded corners or circular mask
                            if (p.shape === 'circle') {
                                // For circular photos
                                targetCtx.save();
                                targetCtx.beginPath();
                                const centerX = x + pWidth / 2;
                                const centerY = y + pHeight / 2;
                                const radius = Math.min(pWidth, pHeight) / 2;
                                targetCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                                targetCtx.closePath();
                                targetCtx.clip();
                                targetCtx.drawImage(img, x, y, pWidth, pHeight);
                                targetCtx.restore();
                            } else if (p.shape === 'rounded') {
                                // For rounded rectangle photos
                                targetCtx.save();
                                targetCtx.beginPath();
                                const radius = Math.min(20, pWidth/4, pHeight/4);
                                targetCtx.moveTo(x + radius, y);
                                targetCtx.lineTo(x + pWidth - radius, y);
                                targetCtx.quadraticCurveTo(x + pWidth, y, x + pWidth, y + radius);
                                targetCtx.lineTo(x + pWidth, y + pHeight - radius);
                                targetCtx.quadraticCurveTo(x + pWidth, y + pHeight, x + pWidth - radius, y + pHeight);
                                targetCtx.lineTo(x + radius, y + pHeight);
                                targetCtx.quadraticCurveTo(x, y + pHeight, x, y + pHeight - radius);
                                targetCtx.lineTo(x, y + radius);
                                targetCtx.quadraticCurveTo(x, y, x + radius, y);
                                targetCtx.closePath();
                                targetCtx.clip();
                                targetCtx.drawImage(img, x, y, pWidth, pHeight);
                                targetCtx.restore();
                            } else {
                                // Default square/rectangle
                                targetCtx.drawImage(img, x, y, pWidth, pHeight);
                            }
                        } catch (error) {
                            console.error(`Could not load image: ${value}`, error);
                            targetCtx.fillStyle = '#fee2e2'; targetCtx.fillRect(x, y, pWidth, pHeight);
                            targetCtx.fillStyle = '#ef4444'; targetCtx.textAlign = 'center'; targetCtx.fillText('X', x + pWidth / 2, y + pHeight / 2);
                        }
                    } else {
                        targetCtx.fillStyle = p.color;
                        targetCtx.font = `${p.fontSize}px Inter`;
                        targetCtx.textAlign = p.align;
                        targetCtx.textBaseline = 'top';
                        const maxWidth = p.width * width;
                        wrapText(targetCtx, value, x, y, maxWidth, p.lineHeight);
                    }
                }
            };
            const drawAllCanvases = (rowData = null) => {
                const w = orientation === 'horizontal' ? HORIZONTAL_WIDTH : HORIZONTAL_HEIGHT;
                const h = orientation === 'horizontal' ? HORIZONTAL_HEIGHT : HORIZONTAL_WIDTH;
                drawCardOnContext(frontCtx, 'front', w, h, rowData);
                drawCardOnContext(backCtx, 'back', w, h, rowData);
            };
            const wrapText = (context, text, x, y, maxWidth, lineHeight) => {
                const words = text.split(' ');
                let line = '';
                let currentY = y;
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        context.fillText(line, x, currentY);
                        line = words[n] + ' ';
                        currentY += lineHeight;
                    } else { line = testLine; }
                }
                context.fillText(line, x, currentY);
            };
            const loadImage = (src) => new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => resolve(img);
                img.onerror = (e) => {
                    console.error("Original image failed to load:", e);
                    // Try using a proxy service if direct loading fails
                    // Only attempt for external URLs (not data URLs)
                    if (src.startsWith('http')) {
                        console.log("Trying with CORS proxy for:", src);
                        const proxyImg = new Image();
                        proxyImg.crossOrigin = "Anonymous";
                        proxyImg.onload = () => resolve(proxyImg);
                        proxyImg.onerror = reject;
                        // Using a more reliable CORS proxy service
                        proxyImg.src = `https://corsproxy.io/?${encodeURIComponent(src)}`;
                    } else {
                        reject(e);
                    }
                };
                img.src = src;
            });
            // --- Placeholder Management ---
            const addPlaceholder = (pData) => {
                // Include shape property for photo placeholders and QR codes
                const base = { 
                    id: `p_${crypto.randomUUID()}`, 
                    key: '', 
                    type: 'text', 
                    x: 0.1, 
                    y: 0.1, 
                    width: 0.3, 
                    height: 0.1, 
                    fontSize: 15, 
                    lineHeight: 18, 
                    color: '#000000', 
                    align: 'left',
                    shape: 'square', // Default shape for photos
                    qrColor: '#000000' // Default QR code color
                };
                const newPlaceholder = { ...base, ...pData };
                placeholders[activeSide].push(newPlaceholder);
                setActivePlaceholder(newPlaceholder.id);
            };
            const renderPlaceholders = () => {
                const renderSide = (side) => {
                    const wrapper = side === 'front' ? frontPlaceholderWrapper : backPlaceholderWrapper;
                    wrapper.innerHTML = '';
                    placeholders[side].forEach(p => {
                        const el = document.createElement('div');
                        el.id = p.id;
                        el.className = `placeholder ${p.type}-placeholder ${p.id === activePlaceholderId ? 'active' : ''}`;
                        el.style.left = `${p.x * 100}%`;
                        el.style.top = `${p.y * 100}%`;
                        el.style.width = `${p.width * 100}%`;
                        el.style.height = `${p.height * 100}%`;
                                                
                        const displayText = p.staticText ? p.staticText : `{{${p.key}}}`;
                        if (p.type === 'qr') {
                            // Enhanced QR placeholder to make it more visible
                            el.innerHTML = `<div class="qr-placeholder-preview">QR: ${p.key}</div>`;
                            
                            // Add a mini visual representation of a QR code
                            const miniQR = document.createElement('div');
                            miniQR.style.width = '30px';
                            miniQR.style.height = '30px';
                            miniQR.style.margin = '4px auto';
                            miniQR.style.backgroundImage = 'linear-gradient(to right, #9333ea 30%, transparent 30%), linear-gradient(to bottom, #9333ea 30%, transparent 30%)';
                            miniQR.style.backgroundSize = '5px 5px';
                            miniQR.style.backgroundPosition = '0 0, 0 0';
                            miniQR.style.opacity = '0.7';
                            el.appendChild(miniQR);
                        } else {
                            el.innerHTML = `<span>${displayText}</span>`;
                        }
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'delete-btn';
                        deleteBtn.innerHTML = '×';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            placeholders[side] = placeholders[side].filter(pl => pl.id !== p.id);
                            if (activePlaceholderId === p.id) setActivePlaceholder(null);
                            else renderPlaceholders();
                        };
                        el.appendChild(deleteBtn);
                                                
                        const resizeHandle = document.createElement('div');
                        resizeHandle.className = 'resize-handle';
                        resizeHandle.addEventListener('mousedown', onResizeStart);
                        el.appendChild(resizeHandle);
                                                
                        el.addEventListener('mousedown', onDragStart);
                        wrapper.appendChild(el);
                    });
                }
                renderSide('front');
                renderSide('back');
            };
            const setActiveSide = (side) => {
                activeSide = side;
                frontCanvasWrapper.classList.toggle('active', side === 'front');
                backCanvasWrapper.classList.toggle('active', side === 'back');
                setActivePlaceholder(null);
            };
            const setActivePlaceholder = (id) => {
                activePlaceholderId = id;
                editPanel.classList.toggle('hidden', !id);
                if (id) renderEditPanel();
                renderPlaceholders();
            };
                        
            // --- Edit Panel ---
            const renderEditPanel = () => {
                const p = placeholders[activeSide].find(pl => pl.id === activePlaceholderId);
                if (!p) return;
                                
                const keyInputLabel = p.staticText ? "Static Text" : "Field Name (from data)";
                const keyInputValue = p.staticText ? p.staticText : p.key;
                let content = `<div><label class="block text-sm font-medium">${keyInputLabel}</label><input type="text" value="${keyInputValue}" oninput="updatePlaceholderProp('${p.id}', '${p.staticText ? 'staticText' : 'key'}', this.value)" class="w-full p-2 border rounded"></div>`;
                                
                if (p.type === 'text') {
                    content += `
                        <div class="grid grid-cols-2 gap-4">
                            <div><label class="block text-sm font-medium">Font Size</label><input type="number" value="${p.fontSize}" oninput="updatePlaceholderProp('${p.id}', 'fontSize', this.value)" class="w-full p-2 border rounded"></div>
                            <div><label class="block text-sm font-medium">Color</label><input type="color" value="${p.color}" oninput="updatePlaceholderProp('${p.id}', 'color', this.value)" class="w-full p-2 h-10 border rounded"></div>
                            <div><label class="block text-sm font-medium">Line Height</label><input type="number" value="${p.lineHeight}" oninput="updatePlaceholderProp('${p.id}', 'lineHeight', this.value)" class="w-full p-2 border rounded"></div>
                        </div>
                        <div><label class="block text-sm font-medium">Alignment</label><div class="flex justify-around bg-gray-100 rounded-lg p-1">
                            <button onclick="updatePlaceholderProp('${p.id}', 'align', 'left')" class="px-3 py-1 rounded ${p.align === 'left' ? 'bg-blue-500 text-white' : ''}">Left</button>
                            <button onclick="updatePlaceholderProp('${p.id}', 'align', 'center')" class="px-3 py-1 rounded ${p.align === 'center' ? 'bg-blue-500 text-white' : ''}">Center</button>
                            <button onclick="updatePlaceholderProp('${p.id}', 'align', 'right')" class="px-3 py-1 rounded ${p.align === 'right' ? 'bg-blue-500 text-white' : ''}">Right</button>
                        </div></div>`;
                } else if (p.type === 'photo') {
                    // Add shape controls for photo fields
                    p.shape = p.shape || 'square'; // Default to square if not set
                    content += `
                        <div><label class="block text-sm font-medium">Photo Shape</label>
                            <div class="flex justify-around bg-gray-100 rounded-lg p-1 mt-2">
                                <button onclick="updatePlaceholderProp('${p.id}', 'shape', 'square')" class="px-3 py-1 rounded ${p.shape === 'square' ? 'bg-blue-500 text-white' : ''}">Square</button>
                                <button onclick="updatePlaceholderProp('${p.id}', 'shape', 'rounded')" class="px-3 py-1 rounded ${p.shape === 'rounded' ? 'bg-blue-500 text-white' : ''}">Rounded</button>
                                <button onclick="updatePlaceholderProp('${p.id}', 'shape', 'circle')" class="px-3 py-1 rounded ${p.shape === 'circle' ? 'bg-blue-500 text-white' : ''}">Circle</button>
                            </div>
                        </div>`;

                } else if (p.type === 'qr') {
                    // Add QR code specific controls
                    p.qrColor = p.qrColor || '#000000'; // Default to black if not set
                    content += `
                        <div><label class="block text-sm font-medium">QR Code Color</label>
                        <input type="color" value="${p.qrColor}" oninput="updatePlaceholderProp('${p.id}', 'qrColor', this.value)" class="w-full p-2 h-10 border rounded"></div>
                        <div class="mt-2 p-2 bg-yellow-50 text-sm text-yellow-800 rounded">
                            QR codes will be generated with the data from field: <strong>${p.key}</strong>
                        </div>`;
                }
                editControls.innerHTML = content;
            };
            window.updatePlaceholderProp = (id, prop, value) => {
                const p = placeholders[activeSide].find(pl => pl.id === id);
                if (p) {
                    const numValue = parseFloat(value);
                    p[prop] = isNaN(numValue) ? value : numValue;
                    renderPlaceholders();
                    // Re-render edit panel when alignment or shape changes
                    if(prop === 'align' || prop === 'shape') {
                        renderEditPanel();
                        // Also redraw the canvas when shape changes to see the effect immediately
                        if (prop === 'shape') {
                            drawAllCanvases();
                        }
                    }
                }
            };
            // --- Interaction Logic ---
            const onDragStart = (e) => {
                if (isResizing) return;
                e.preventDefault(); e.stopPropagation();
                const target = e.target.closest('.placeholder');
                if (!target) return;
                if (activePlaceholderId !== target.id) setActivePlaceholder(target.id);
                const elementToDrag = document.getElementById(target.id);
                if (!elementToDrag) return;
                dragOffsetX = e.clientX - elementToDrag.getBoundingClientRect().left;
                dragOffsetY = e.clientY - elementToDrag.getBoundingClientRect().top;
                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
            };
            const onDragMove = (e) => {
                const activeEl = document.getElementById(activePlaceholderId);
                if (!activeEl) return;
                const wrapper = activeSide === 'front' ? frontPlaceholderWrapper : backPlaceholderWrapper;
                const wrapperRect = wrapper.getBoundingClientRect();
                let x = e.clientX - wrapperRect.left - dragOffsetX;
                let y = e.clientY - wrapperRect.top - dragOffsetY;
                x = Math.max(0, Math.min(x, wrapperRect.width - activeEl.offsetWidth));
                y = Math.max(0, Math.min(y, wrapperRect.height - activeEl.offsetHeight));
                activeEl.style.left = `${x}px`;
                activeEl.style.top = `${y}px`;
            };
            const onDragEnd = () => {
                const activeEl = document.getElementById(activePlaceholderId);
                if (activeEl) {
                    const pData = placeholders[activeSide].find(p => p.id === activePlaceholderId);
                    if (pData) {
                        const wrapper = activeSide === 'front' ? frontPlaceholderWrapper : backPlaceholderWrapper;
                        const wrapperRect = wrapper.getBoundingClientRect();
                        pData.x = activeEl.offsetLeft / wrapperRect.width;
                        pData.y = activeEl.offsetTop / wrapperRect.height;
                    }
                }
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('mouseup', onDragEnd);
            };
            const onResizeStart = (e) => {
                e.preventDefault(); e.stopPropagation();
                isResizing = true;
                const target = e.target.closest('.placeholder');
                if (!target) return;
                if (activePlaceholderId !== target.id) setActivePlaceholder(target.id);
                document.addEventListener('mousemove', onResizeMove);
                document.addEventListener('mouseup', onResizeEnd);
            };
            const onResizeMove = (e) => {
                const activeEl = document.getElementById(activePlaceholderId);
                const pData = placeholders[activeSide].find(p => p.id === activePlaceholderId);
                if (!activeEl || !pData) return;
                const wrapper = activeSide === 'front' ? frontPlaceholderWrapper : backPlaceholderWrapper;
                const wrapperRect = wrapper.getBoundingClientRect();
                const newWidth = e.clientX - activeEl.getBoundingClientRect().left;
                const newHeight = e.clientY - activeEl.getBoundingClientRect().top;
                pData.width = Math.max(20 / wrapperRect.width, newWidth / wrapperRect.width);
                pData.height = Math.max(20 / wrapperRect.height, newHeight / wrapperRect.height);
                renderPlaceholders();
                renderEditPanel();
            };
            const onResizeEnd = () => {
                isResizing = false;
                document.removeEventListener('mousemove', onResizeMove);
                document.removeEventListener('mouseup', onResizeEnd);
            };
            document.addEventListener('keydown', (e) => {
                if (!activePlaceholderId) return;
                const pData = placeholders[activeSide].find(p => p.id === activePlaceholderId);
                if (!pData) return;
                const wrapper = activeSide === 'front' ? frontPlaceholderWrapper : backPlaceholderWrapper;
                const smallStep = 1 / wrapper.offsetWidth;
                const largeStep = 10 / wrapper.offsetWidth;
                const step = e.shiftKey ? largeStep : smallStep;
                let needsRender = false;
                switch (e.key) {
                    case 'ArrowUp': pData.y -= step; needsRender = true; break;
                    case 'ArrowDown': pData.y += step; needsRender = true; break;
                    case 'ArrowLeft': pData.x -= step; needsRender = true; break;
                    case 'ArrowRight': pData.x += step; needsRender = true; break;
                }
                if (needsRender) { e.preventDefault(); renderPlaceholders(); }
            });
            // --- Gemini API Call ---
            const callGemini = async (prompt, jsonSchema = null) => {
                loadingModal.classList.remove('hidden');
                
                // You need to get your own API key from https://aistudio.google.com/
                // This is left blank deliberately and will need to be filled in
                // with your own API key or handled through environment variables
                const apiKey = prompt("Please enter your Gemini API key to use AI features:"); 
                
                if (!apiKey) {
                    loadingModal.classList.add('hidden');
                    errorText.textContent = "API key is required for AI features.";
                    errorModal.classList.remove('hidden');
                    return null;
                }
                
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`;
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                if (jsonSchema) {
                    payload.generationConfig = { responseMimeType: "application/json", responseSchema: jsonSchema };
                }
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        const errorBody = await response.json();
                        throw new Error(`API Error: ${errorBody.error?.message || 'Unknown error'}`);
                    }
                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!text) throw new Error("No content received from API.");
                    return text;
                } catch (error) {
                    console.error("Gemini API call failed:", error);
                    errorText.textContent = error.message || "An unknown error occurred.";
                    errorModal.classList.remove('hidden');
                    return null;
                } finally {
                    loadingModal.classList.add('hidden');
                }
            };
            // --- Orientation Logic ---
            const setOrientation = (newOrientation) => {
                if (orientation === newOrientation) return;
                orientation = newOrientation;
                                
                const isHorizontal = newOrientation === 'horizontal';
                const newW = isHorizontal ? HORIZONTAL_WIDTH : HORIZONTAL_HEIGHT;
                const newH = isHorizontal ? HORIZONTAL_HEIGHT : HORIZONTAL_WIDTH;
                [frontCanvas, backCanvas].forEach(c => {
                    c.width = newW;
                    c.height = newH;
                });
                [frontCanvasWrapper, backCanvasWrapper].forEach(w => {
                    w.style.aspectRatio = `${newW} / ${newH}`;
                });
                orientationHorizontalBtn.classList.toggle('bg-blue-500', isHorizontal);
                orientationHorizontalBtn.classList.toggle('text-white', isHorizontal);
                orientationVerticalBtn.classList.toggle('bg-blue-500', !isHorizontal);
                orientationVerticalBtn.classList.toggle('text-white', !isHorizontal);
                drawAllCanvases();
                renderPlaceholders();
            };
            // --- Event Listeners ---
            const setupBgImageInput = (input, side) => {
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => { bgImages[side].src = event.target.result; };
                        reader.readAsDataURL(file);
                    }
                });
            };
            setupBgImageInput(bgImageFrontInput, 'front');
            setupBgImageInput(bgImageBackInput, 'back');
            dataFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        let parsedData = [];
                        if (file.name.endsWith('.csv')) {
                            // Basic CSV parsing
                            const content = event.target.result;
                            const lines = content.split('\n');
                            const headerLine = lines[0];
                            const csvHeaders = headerLine.split(',').map(h => h.trim());
                            
                            for (let i = 1; i < lines.length; i++) {
                                if (!lines[i].trim()) continue;
                                const values = lines[i].split(',').map(v => v.trim());
                                const rowData = {};
                                csvHeaders.forEach((header, index) => {
                                    rowData[header] = values[index] || '';
                                });
                                parsedData.push(rowData);
                            }
                        } else {
                            // XLSX parsing
                            const workbook = XLSX.read(event.target.result, { type: 'binary' });
                            const sheetName = workbook.SheetNames[0];
                            parsedData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
                        }
                        
                        data = parsedData;
                        if (data.length > 0) {
                            headers = Object.keys(data[0]);
                            
                            // Populate QR code field select dropdown
                            qrFieldSelect.innerHTML = '<option value="">Select a field from data</option>';
                            headers.forEach(header => {
                                const option = document.createElement('option');
                                option.value = header;
                                option.textContent = header;
                                qrFieldSelect.appendChild(option);
                            });
                            
                            // Enable QR field select
                            qrFieldSelect.disabled = false;
                            document.getElementById('qr-field-container').classList.remove('opacity-70');
                            
                            aiControls.classList.remove('opacity-50');
                            aiLayoutBtn.disabled = false;
                            aiTitleBtn.disabled = false;
                            addAllHeadersBtn.disabled = false;
                            previewBtn.disabled = false;
                            generateZipBtn.disabled = false;
                            generatePdfBtn.disabled = false;
                            alert(`${data.length} records loaded successfully!`);
                        } else { 
                            alert('The file seems to be empty or in an incorrect format.'); 
                        }
                    } catch (error) {
                        console.error("Failed to parse data file:", error);
                        alert(`Error parsing file: ${error.message}`);
                    }
                };
                
                if (file.name.endsWith('.csv')) {
                    reader.readAsText(file);
                } else {
                    reader.readAsBinaryString(file);
                }
            });
                        
            aiLayoutBtn.addEventListener('click', async () => {
                loadingText.textContent = `Designing the ${activeSide} of the card...`;
                const w = orientation === 'horizontal' ? HORIZONTAL_WIDTH : HORIZONTAL_HEIGHT;
                const h = orientation === 'horizontal' ? HORIZONTAL_HEIGHT : HORIZONTAL_WIDTH;
                const prompt = `Based on these data headers for the ${activeSide} of an ID card, create a logical layout for a ${orientation} card. Headers: ${headers.join(', ')}. The canvas is ${w}x${h}. A photo field should be about 1/4 of the width and 1/2 of the height for vertical, or 1/4 height and 1/3 width for horizontal. Place the most important info prominently. Identify which field is likely the photo.`;
                const schema = { type: "ARRAY", items: { type: "OBJECT", properties: { key: { type: "STRING" }, type: { type: "STRING", enum: ["text", "photo"] }, x: { type: "NUMBER" }, y: { type: "NUMBER" }, width: { type: "NUMBER" }, height: { type: "NUMBER" } }, required: ["key", "type", "x", "y", "width", "height"] } };
                const result = await callGemini(prompt, schema);
                if (result) {
                    try {
                        placeholders[activeSide] = [];
                        const layout = JSON.parse(result);
                        layout.forEach(p => {
                            const base = p.type === 'text' ? { fontSize: 15, lineHeight: 18, color: '#000000', align: 'left' } : {};
                            addPlaceholder({ ...p, ...base });
                        });
                    } catch (error) {
                        console.error("Failed to parse AI layout:", error);
                        errorText.textContent = "Could not process the AI-generated layout. Try again.";
                        errorModal.classList.remove('hidden');
                    }
                }
            });
            aiTitleBtn.addEventListener('click', async () => {
                loadingText.textContent = "Generating a professional title...";
                const prompt = `Based on these data headers, suggest a short, professional title for the ID card. For example, "Employee ID" or "Student Pass". Headers: ${headers.join(', ')}`;
                const result = await callGemini(prompt);
                if (result) {
                    addPlaceholder({ key: 'title', type: 'text', x: 0.1, y: 0.05, width: 0.8, height: 0.1, fontSize: 36, staticText: result.replace(/"/g, '') });
                }
            });
            addAllHeadersBtn.addEventListener('click', () => {
                if (headers.length === 0) return;
                let yOffset = 0.1;
                headers.forEach(header => {
                    // Check if the header name contains "photo" or "image" and make it a photo field
                    const type = header.toLowerCase().includes('photo') || header.toLowerCase().includes('image') ? 'photo' : 'text';
                    
                    // For photo fields, adjust the height and width proportions and make it circular
                    const options = type === 'photo' ? 
                        { width: 0.25, height: 0.3, x: 0.7, y: 0.1, shape: 'circle' } : 
                        { y: yOffset };
                    
                    addPlaceholder({ key: header, type, ...options });
                    
                    // Only increment yOffset for text fields
                    if (type === 'text') yOffset += 0.1;
                });
            });
            orientationHorizontalBtn.addEventListener('click', () => setOrientation('horizontal'));
            orientationVerticalBtn.addEventListener('click', () => setOrientation('vertical'));
            frontCanvasWrapper.addEventListener('click', () => setActiveSide('front'));
            backCanvasWrapper.addEventListener('click', () => setActiveSide('back'));
            addTextBtn.addEventListener('click', () => addPlaceholder({ key: fieldNameInput.value || 'New Text', type: 'text' }));
            addPhotoBtn.addEventListener('click', () => addPlaceholder({ key: fieldNameInput.value || 'New Photo', type: 'photo', shape: 'circle' }));
            addQrBtn.addEventListener('click', () => {
                // Get the field from the QR select dropdown or fall back to the input field if empty
                const qrField = qrFieldSelect.value || fieldNameInput.value || 'ID';
                
                // Check if this field exists in the data
                if (data.length > 0 && !headers.includes(qrField) && qrField !== 'ID') {
                    alert(`Warning: The field "${qrField}" doesn't exist in your data. QR code may not appear in preview or export.`);
                }
                
                // Add QR code with more specific positioning
                addPlaceholder({ 
                    key: qrField, 
                    type: 'qr', 
                    width: 0.25,   // 25% of card width
                    height: 0.25,  // 25% of card height
                    x: 0.65,       // Right side of card
                    y: 0.20,       // Upper part of card
                    qrColor: '#000000' // Force black for better contrast
                });
                
                // Create alert to confirm QR code was added
                alert(`QR code for field "${qrField}" added. For best results:\n1. Preview to check visibility\n2. Adjust size/position if needed\n3. Make sure field exists in your data`);
                
                // Log to help with debugging
                console.log(`Added QR code for field: ${qrField}`);
                console.log(`Available data fields: ${headers.join(', ')}`);
            });
            // QR Code button event handler already defined above
                        
            previewBtn.addEventListener('click', async () => {
                if (data.length === 0) { alert('Please upload data to preview.'); return; }
                setActivePlaceholder(null);
                frontPlaceholderWrapper.style.display = 'none';
                backPlaceholderWrapper.style.display = 'none';
                
                // Force redraw of canvases with the first record
                console.log("Previewing with data:", data[0]);
                console.log("Current QR placeholder settings:", placeholders.front.filter(p => p.type === 'qr'));
                
                // Force redraw with hard-coded position for QR
                await drawAllCanvases(data[0]);
                
                const backButton = document.createElement('button');
                backButton.innerText = 'Back to Edit';
                backButton.className = 'absolute top-2 right-2 bg-yellow-400 text-black font-bold py-1 px-3 rounded z-30';
                backButton.onclick = () => { 
                    frontPlaceholderWrapper.style.display = 'block'; 
                    backPlaceholderWrapper.style.display = 'block'; 
                    drawAllCanvases(); 
                    backButton.remove(); 
                };
                document.getElementById('front-canvas-wrapper').appendChild(backButton);
            });

            // PDF Generation Logic
            generatePdfBtn.addEventListener('click', async () => {
                if (data.length === 0) { 
                    alert('Please upload data and add fields before generating.'); 
                    return; 
                }
                    
                loadingModal.classList.remove('hidden');
                loadingText.textContent = 'Generating A4 PDF...';
                    
                try {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF({ orientation: 'l', unit: 'mm', format: 'a4' });
                        
                    const isHorizontal = orientation === 'horizontal';
                    const cardWidthMM = isHorizontal ? 85.6 : 54.0;
                    const cardHeightMM = isHorizontal ? 54.0 : 85.6;
                        
                    // Optimized for 5 cards per row on A4 landscape (297mm x 210mm)
                    const cardsPerRow = 5;
                    const pageWidth = 297;
                    const pageHeight = 210;
                    
                    // Calculate optimal spacing for 5 cards
                    const totalCardsWidth = cardsPerRow * cardWidthMM;
                    const availableSpaceForGaps = pageWidth - totalCardsWidth;
                    const cardSpacing = availableSpaceForGaps / (cardsPerRow + 1); // Equal spacing including margins
                    
                    const frontRowY = 15; // Top margin
                    const backRowY = frontRowY + cardHeightMM + 15; // Space between front and back rows
                    
                    // Create temporary canvas for rendering
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = isHorizontal ? HORIZONTAL_WIDTH : HORIZONTAL_HEIGHT;
                    tempCanvas.height = isHorizontal ? HORIZONTAL_HEIGHT : HORIZONTAL_WIDTH;
                    const tempCtx = tempCanvas.getContext('2d');

                    // Process cards in batches of 5
                    for (let i = 0; i < data.length; i += cardsPerRow) {
                        if (i > 0) pdf.addPage(); // New page for each batch
                        
                        // Process each card in this batch
                        for (let j = 0; j < cardsPerRow && (i + j) < data.length; j++) {
                            const cardData = data[i + j];
                            const cardX = cardSpacing + (j * (cardWidthMM + cardSpacing));
                            
                            // Draw FRONT card (top row)
                            await drawCardOnContext(tempCtx, 'front', tempCanvas.width, tempCanvas.height, cardData);
                            const frontDataUrl = tempCanvas.toDataURL('image/png');
                            pdf.addImage(frontDataUrl, 'PNG', cardX, frontRowY, cardWidthMM, cardHeightMM);
                            
                            // Draw BACK card (bottom row, rotated 180 degrees for proper double-sided printing)
                            // Create a temporary canvas for rotation
                            const rotatedCanvas = document.createElement('canvas');
                            rotatedCanvas.width = tempCanvas.width;
                            rotatedCanvas.height = tempCanvas.height;
                            const rotatedCtx = rotatedCanvas.getContext('2d');

                            // Draw the back card normally first
                            await drawCardOnContext(tempCtx, 'back', tempCanvas.width, tempCanvas.height, cardData);

                            // Now rotate and draw it on the rotated canvas
                            rotatedCtx.translate(rotatedCanvas.width/2, rotatedCanvas.height/2);
                            rotatedCtx.rotate(Math.PI); // 180 degrees
                            rotatedCtx.translate(-rotatedCanvas.width/2, -rotatedCanvas.height/2);
                            rotatedCtx.drawImage(tempCanvas, 0, 0);

                            const backDataUrl = rotatedCanvas.toDataURL('image/png');
                            pdf.addImage(backDataUrl, 'PNG', cardX, backRowY, cardWidthMM, cardHeightMM);
                        }
                    }

                    pdf.save('ID_Cards_Double_Sided_5_Per_Sheet.pdf');
                } catch (error) {
                    console.error("Failed to generate PDF:", error);
                    errorText.textContent = `Error generating PDF: ${error.message}`;
                    errorModal.classList.remove('hidden');
                } finally {
                    loadingModal.classList.add('hidden');
                }
            });

            // ZIP Generation Logic
            generateZipBtn.addEventListener('click', async () => {
                if (data.length === 0) { alert('Please upload data and add fields before generating.'); return; }
                setActivePlaceholder(null);
                loadingModal.classList.remove('hidden');
                loadingText.textContent = 'Generating ZIP...';
                
                try {                
                    const zip = new JSZip();
                    const tempCanvas = document.createElement('canvas');
                    const w = orientation === 'horizontal' ? HORIZONTAL_WIDTH : HORIZONTAL_HEIGHT;
                    const h = orientation === 'horizontal' ? HORIZONTAL_HEIGHT : HORIZONTAL_WIDTH;
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    for (let i = 0; i < data.length; i++) {
                        const baseName = `ID_Card_${data[i].ID || data[i].id || i + 1}`;
                                            
                        await drawCardOnContext(tempCtx, 'front', w, h, data[i]);
                        zip.file(`${baseName}_Front.png`, tempCanvas.toDataURL('image/png').split(',')[1], { base64: true });
                                            
                        await drawCardOnContext(tempCtx, 'back', w, h, data[i]);
                        zip.file(`${baseName}_Back.png`, tempCanvas.toDataURL('image/png').split(',')[1], { base64: true });
                        
                        // Update loading message
                        if (i % 5 === 0) {
                            loadingText.textContent = `Generating ZIP... (${i+1}/${data.length} cards)`;
                        }
                    }
                    
                    const content = await zip.generateAsync({ type: 'blob' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(content);
                    link.download = 'ID_Cards_Double_Sided.zip';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    console.error("Failed to generate ZIP:", error);
                    errorText.textContent = `Error generating ZIP: ${error.message}`;
                    errorModal.classList.remove('hidden');
                } finally {
                    loadingModal.classList.add('hidden');
                }
            });
            
            // --- Layout Management ---
            const saveLayout = () => {
                const layoutName = layoutNameInput.value.trim();
                if (!layoutName) {
                    alert("Please enter a name for your layout!");
                    return;
                }
                
                // Create an object with all layout data
                const layoutData = {
                    name: layoutName,
                    orientation: orientation,
                    placeholders: {
                        front: placeholders.front,
                        back: placeholders.back
                    },
                    dateCreated: new Date().toISOString()
                };
                
                // Get existing layouts from localStorage or initialize empty object
                const savedLayouts = JSON.parse(localStorage.getItem('idCardLayouts') || '{}');
                
                // Add/update this layout
                savedLayouts[layoutName] = layoutData;
                
                // Save back to localStorage
                localStorage.setItem('idCardLayouts', JSON.stringify(savedLayouts));
                
                // Update the dropdown
                updateLayoutSelect();
                
                alert(`Layout "${layoutName}" saved successfully!`);
            };
            
            const loadLayout = (layoutName) => {
                const savedLayouts = JSON.parse(localStorage.getItem('idCardLayouts') || '{}');
                const layout = savedLayouts[layoutName];
                
                if (!layout) {
                    alert("Layout not found!");
                    return;
                }
                
                // Set orientation
                setOrientation(layout.orientation);
                
                // Load placeholders
                placeholders.front = JSON.parse(JSON.stringify(layout.placeholders.front));
                placeholders.back = JSON.parse(JSON.stringify(layout.placeholders.back));
                
                // Redraw everything
                renderPlaceholders();
                drawAllCanvases();
                
                alert(`Layout "${layoutName}" loaded successfully!`);
            };
            
            const updateLayoutSelect = () => {
                // Clear existing options except the first default one
                while (layoutSelect.options.length > 1) {
                    layoutSelect.remove(1);
                }
                
                // Get saved layouts
                const savedLayouts = JSON.parse(localStorage.getItem('idCardLayouts') || '{}');
                
                // Add each layout to the dropdown
                for (const layoutName in savedLayouts) {
                    const option = document.createElement('option');
                    option.value = layoutName;
                    option.textContent = layoutName;
                    layoutSelect.appendChild(option);
                }
            };
            
            // --- Event Listeners for Layout Management ---
            saveLayoutBtn.addEventListener('click', saveLayout);
            
            loadLayoutBtn.addEventListener('click', () => {
                const selectedLayout = layoutSelect.value;
                if (!selectedLayout) {
                    alert("Please select a layout to load!");
                    return;
                }
                loadLayout(selectedLayout);
            });
            
            deleteLayoutBtn.addEventListener('click', () => {
                const selectedLayout = layoutSelect.value;
                if (!selectedLayout) {
                    alert("Please select a layout to delete!");
                    return;
                }
                
                if (confirm(`Are you sure you want to delete the layout "${selectedLayout}"? This cannot be undone.`)) {
                    const savedLayouts = JSON.parse(localStorage.getItem('idCardLayouts') || '{}');
                    
                    // Remove the selected layout
                    delete savedLayouts[selectedLayout];
                    
                    // Save back to localStorage
                    localStorage.setItem('idCardLayouts', JSON.stringify(savedLayouts));
                    
                    // Update the dropdown
                    updateLayoutSelect();
                    
                    // Clear the name input
                    layoutNameInput.value = '';
                    
                    alert(`Layout "${selectedLayout}" has been deleted.`);
                }
            });
            
            layoutSelect.addEventListener('change', () => {
                const selectedLayout = layoutSelect.value;
                if (selectedLayout) {
                    layoutNameInput.value = selectedLayout;
                }
            });
            
            exportLayoutsBtn.addEventListener('click', () => {
                const savedLayouts = JSON.parse(localStorage.getItem('idCardLayouts') || '{}');
                
                if (Object.keys(savedLayouts).length === 0) {
                    alert("No layouts to export. Please create and save a layout first.");
                    return;
                }
                
                // Create a data object with metadata
                const exportData = {
                    type: "ID_Card_Generator_Layouts",
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    layouts: savedLayouts
                };
                
                // Convert to JSON string
                const jsonStr = JSON.stringify(exportData, null, 2);
                
                // Create a downloadable file
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ID_Card_Layouts_' + new Date().toISOString().replace(/[:.]/g, '-') + '.json';
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 0);
            });
            
            importLayoutsBtn.addEventListener('click', () => {
                // Create a hidden file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'application/json';
                fileInput.style.display = 'none';
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const importedData = JSON.parse(event.target.result);
                            
                            // Validate that it's an ID card layout file
                            if (!importedData.type || importedData.type !== "ID_Card_Generator_Layouts") {
                                throw new Error("Invalid layout file format");
                            }
                            
                            // Get current layouts
                            const currentLayouts = JSON.parse(localStorage.getItem('idCardLayouts') || '{}');
                            
                            // Count imported layouts
                            const importCount = Object.keys(importedData.layouts).length;
                            
                            // Handle conflicts or merge
                            let conflictCount = 0;
                            let mergeCount = 0;
                            
                            for (const [name, layout] of Object.entries(importedData.layouts)) {
                                if (currentLayouts[name]) {
                                    conflictCount++;
                                    // Let's overwrite by default, but you could add more complex logic here
                                } else {
                                    mergeCount++;
                                }
                                currentLayouts[name] = layout;
                            }
                            
                            // Save merged layouts
                            localStorage.setItem('idCardLayouts', JSON.stringify(currentLayouts));
                            
                            // Update the dropdown
                            updateLayoutSelect();
                            
                            alert(`Successfully imported ${importCount} layouts!\n- ${mergeCount} new layouts added\n- ${conflictCount} existing layouts updated`);
                            
                        } catch (error) {
                            console.error("Import error:", error);
                            alert(`Error importing layouts: ${error.message}`);
                        }
                    };
                    
                    reader.readAsText(file);
                });
                
                // Append and trigger click
                document.body.appendChild(fileInput);
                fileInput.click();
                
                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(fileInput);
                }, 0);
            });
            
            // --- Initial Setup ---
            const initialSetup = () => {
                // Set canvas dimensions based on orientation
                const w = HORIZONTAL_WIDTH;
                const h = HORIZONTAL_HEIGHT;
                [frontCanvas, backCanvas].forEach(c => {
                    c.width = w;
                    c.height = h;
                });
                [frontCanvasWrapper, backCanvasWrapper].forEach(w => {
                    w.style.aspectRatio = `${HORIZONTAL_WIDTH} / ${HORIZONTAL_HEIGHT}`;
                });
                
                // Setup background image loading
                bgImages.front.onload = () => drawAllCanvases();
                bgImages.back.onload = () => drawAllCanvases();
                
                // Load default backgrounds
                bgImages.front.src = defaultBgDataUrl;
                bgImages.back.src = defaultBackBgDataUrl;
                
                // Set initial state
                setOrientation('horizontal');
                setActiveSide('front');
                
                // Load saved layouts into the dropdown
                updateLayoutSelect();
                
                // Create basic demo data if needed
                if (data.length === 0) {
                    // Optional: add some sample data for demo purposes
                    // data = [{ Name: "John Doe", ID: "12345", Position: "Developer", Photo: "path/to/sample.jpg" }];
                    // headers = Object.keys(data[0]);
                }
            };
            
            initialSetup();
        });
    </script>
</body>
</html>
